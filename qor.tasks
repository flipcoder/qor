[|] obj mesh needs to generate tangents
    [>] calc tangents
    [x] avg tangents
* pipeline changes
    [-] merge Pipeline and Pass
* mathy stuff
    [|] frustum culling
        [ ] perspective 
    * collision
        [?] Node-box-contains-subnodes guarentee
            # when child added, register listener for move/add
            # node needs vector of scoped_connections (?)
            # flag box for recalculation on child's on_move
[|] make partitioner find light nodes (using Node::is_light())
[|] turn basic shader into lit
    # almost done here, just need to get light data into shader
[ ] Allow custom materials to invoke shader swaps
    Order of events for this is:
        - Optionally, the mesh looks at current LOD level, stored in Pass
            in: Mesh::render_self
        - Each Mesh modifier sets flags for what attributes they will provide data for
        - The material is queried with these flags for compatibility
        - Depending on the pass and the texture's logic, the material may change the shader (if needed)
            If this happens:
            - It will ensure the texture is bound as well as other uniforms the texture may need (texture matrix?)
            - tells pass to update all the other uniforms for the custom shader
            - Some scoped object returned by Texture should call pass->shader(nullptr) after the render
            - it is likely that this shader will be used again in the next mesh
[ ] ingame console w/ python commands
    # already have python scripting integration, just need the gui for this
* physics
    [|] implement bullet
    [ ] improve character controller
* input
    [x] mouse buttons as controller buttons
    [|] gamepad buttons as controller buttons
[>] particle system
[|] JSON Scene format
[ ] BUG: when state needs_load() is false, enter() is not executed
[ ] convert tile uv generation to texture atlas

